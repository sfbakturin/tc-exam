# Минимальная решетка линейного блокового кода и способы ее построения. Алгоритм Витерби

Пусть есть некоторый двоичный $(n, k, d)$ код $C$ с известной порождающей матрицей $G$ и некая функция метрики. Наша задача - научиться декодировать поданный нам вектор $y$ по максимум правдоподобия:

$$
    \hat{c} = \argmin_{c \in C}{\left(D(c, y)\right)} = \argmin_{c \in C}{\left(\sum_{i = 0}^{n - 1}{\left(D(c_{i}, y_{i})\right)}\right)}
$$

По методу правдоподобия мы занимаемся поиском ближайшего к ответу кодового слова - это и есть задача *декодирования* вектора $y$. Для оптимизации процесса в таких случаях, когда наше слово лежит на некотором вещественном расстоянии до кодового слова, принадлежащий $C$, используется граф и решается задача *поиска кратчайшего пути на графе*.

---

**Решётка** - граф, обладающий следующими свойствами:

* вершины разбиты на непересекающиеся подмножества (так называемые *уровни* или *ярусы*),
* нулевой и последний ярусы содержат по 1 узлу (так называемые *терминальные узлы*),
* граф обязательно направленный и направлен в одну сторону - движение только от уровня с меньшим номером к уровню с большим номером,
* ребрам графа приписаны метки, соответствующие символам кодовых слов, а также метрики, называемые также *весами* или *длинами*,
* длина пути равна сумме длин входящих в него ребер

Сопоставим пути в решетке между терминальными узлами кодовым словам. Тогда задача поиска кодового слова, минимизирующего некоторую аддитивную функцию длины (то есть, поиска самого ближайшего слова к поданному вектору $y$) эквивалентна задаче поиска кратчайшего пути между терминальными узлами решетки.

---

Назовём $(\xi_{0}, \ldots, \xi_{n})$, где $\xi_{i} = |V_{i}|$, то есть количество вершин на некотором уровне $i$, *профилем сложности решётки*.

**Минимальная решётка** - это решётка, если профиль сложности $(\xi_{0}', \ldots, \xi_{n}')$ любой другой решетки удовлетворяет $\xi_{i}' \geqslant \xi_{i}, ~ 0 \leqslant i \leqslant n$.

Существует как минимум два способа построения минимальной решётки кода: через *проверочную* матрицу и через *минимальную спэновую форму* порождающей матрицы.

Построение минимальной решётки через проверочную матрицу:

* Пусть дана проверочная матрица $H = (h_0, \ldots, h_{n - 1})$
* Пусть $S_0 = 0$ (синдром)
* Введем накопленный синдром: $S(x_0, \ldots, x_{j - 1}) = \sum_{i = 0}^{j - 1}{\left(h_{i}x_{i}\right)}$
* Будем нумеровать узлы $v$ в решетке накопленными синдромами $S(v)^{T}$
* Существует ребро, помеченное $c$, из $v'$ на ярусе $i$ в $v$ на ярусе $i + 1$, если $S(v) = S(v') + ch_{i}$
* Оставим единственный конечный узел, соответствующий *нулевому синдрому*, то есть, другими словами, *допустимым кодовым словам*
* Удалим нетерминальные узлы, из которых не выходят ребра

Решетка, получаемая по проверочной матрице, **минимальна**.

Началом $b(x)$ вектора $(x_0, \ldots, x_{n - 1})$ будем называть номер *первого его ненулевого элемента*. Концом $e(x)$ вектора $(x_0, \ldots, x_{n - 1})$ будем называть номер *последнего его ненулевого элемента*. Порождающая матрица называется приведенной к **минимальной спэновой форме** (**МСФ**), если все начала строк различны и все концы строк различны. Для определенности потребуем также, чтобы строки матрицы были упорядочены по возрастанию начал строк. Матрица может быть приведена к МСФ с помощью элементарных операций над строками, подобных *алгоритму Гаусса*. Элементы на позициях $b(x), \ldots, e(x) - 1$ будем называть *активными*.

Построение минимальной решётки через минимальную спэновую форму:

* Скажем, что $G$ теперь находится в минимальной спэновой форме.
* На ярусе $i$ узлы нумеруются значениями информационных символов, соответствующих строкам МСФ, активным в позиции $i$. Грубо говоря: у нас есть упорядоченное множество активных строк $A = \{x_{a}, x_{b}, \ldots\}$ для некоторого яруса $i$ и есть $A'$ для яруса $i + 1$, мы рассматриваем три основных случая (по свойствам МСФ):
  * либо $A = A'$, тогда ребро проводится в соответствии значений битового вектора на позициях соответствующих $x \in A'$,
  * иначе, ребро проводится в соответствии значений битового вектора на позициях соответствующих $x \in A'$.
* Ребра помечаются линейными комбинациями активных элементов столбца порождающей матрицы. Грубо говоря, следующему ярусу $i + 1$ соответствует вектор, составленный из столбца $i + 1$, текущему ярусу $i$ соответствует вектор, составленный из битовых значений по соответствующем позициям $x \in A$ - поэтому этого вектора перемножаются и по четности/нечетности произведения выбирается значение на ребре (либо `0`, либо `1`).

Решетка, получаемая по порождающей матрице в МСФ, **минимальна**.

---

Возвращаясь к *задаче поиска кратчайшего пути между терминальными узлами решетки* мы помним, что мы строим *решётку*, то есть граф, проходя по которому мы собираем всевозможные кодовые слова кода $C$ и можем декодировать слово поиском кратчайшего в весовом эквиваленте, как бы накапливая (то есть, суммирая), проходя по существующим переходам (ребрам).

В решетке существует множество путей, причем эти пути могут расходиться и сходиться. Если имеются два пути $(c'|c)$ и $(c''|c)$ с общим хвостом, оптимальным может быть только тот из этих путей, который имеет меньшую метрику первой части. Это дает возможность воспользоваться принципом динамического программирования, который лежит в основе *алгоритма Витерби*.

**Алгоритм Витерби**:

* Пусть
  * $M_{i, v}$ - метрика узла $v$ на ярусе $i$.
  * $V_i$ - множество узлов на ярусе $i$.
  * $c[i, v', v]$ - метка ребра между узлами, где $v' \in V_{i - 1}$ и $v \in V_{i}$.
  * Число сложений не превосходит $E$ (число ребер в решетке).
  * Число сравнений не превосходит $E - V$, где $V$ - число узлов.
* Тогда, скажем, что $M_{0, 0} \gets 0$.
* Далее для каждого яруса $i = 1, \ldots n$ и для каждой вершины, входящий в этот ярус $v \in V_{i}$
  * Для каждого входящего ребра $(v', v)$ вычисляем метрику его пути $M_{v', v} = M_{i - 1, v'} + D{\left(c[u, v', v], y_{i - 1}\right)}$, где $y_{i - 1}$ - это значение поданного вектора на $i - 1$ позиции.
  * Метрика узла $M_{i, v} = \min{\left(M_{v', v}\right)}$.
  * Узлом-родителем мы установим с минимальным расстоянием $B_{i, v} = \argmin{\left(M_{v', v}\right)}$.
* Наконец, восстановим путь (то есть, восстановим кодовое слово) по минимальным расстояниям.
